# タスク1: ターミナル管理クラス (`ConchSession`) の設計と実装

## 1-1. インターフェース定義 (`types.ts`)
- [x] `IPty` (または `ITerminalBackend`) インターフェースを定義する
- [x] `write`, `resize`, `onData`, `dispose` などの必須メソッドを決定する
### memo
- 必須メソッド: `write`(UTF-8 string), `resize`(cols, rows), `dispose`(終了/切断)
- イベント: `onData`(stdout/stderr混合), `onExit`(終了コード)
- ID: PIDだけでなくコンテナID等も考慮し `string | number`
- 初期化: 接続確立後のインスタンスを扱う前提（Connectは含まない）

## 1-2. 基底クラス/アダプター作成
- [x] `node-pty` をラップして上記インターフェースに適合させる `LocalPty` クラスを作成する
- [x] 将来的な Docker/SSH 対応を見据えた構造にする
### memo
- `LocalPty` は `node-pty` 専用アダプタであり、Docker/SSH等は別クラスで `ITerminalBackend` を実装する（継承関係ではない）。
- コンストラクタ引数は `shell` と共通オプション `cols, rows, env, cwd` に絞り、`node-pty` への依存を隠蔽する。
- Windows環境での `chcp 65001` (UTF-8化) は、ドメイン知識として `LocalPty` クラス内部（spawn直後）に隠蔽する。

## 1-3. セッションクラスの雛形作成 (`session.ts`)
- [x] `ConchSession` クラスを作成する
- [x] コンストラクタで `IPty` と `@xterm/headless` の `Terminal` インスタンスを初期化する
### memo
- 設計方針: 依存性注入(DI)を採用。コンストラクタで `ITerminalBackend` インスタンスを受け取る。
- 責務: バックエンド(Pty)とフロントエンド(xterm)のパイプライン接続を管理するコントローラー。
- サイズ同期: 呼び出し側が責任を持ってバックエンドとセッション（xterm）に同じサイズ指定を行う前提とし、セッション内での強制同期は行わない。

## 1-4. パイプラインの接続
- [x] `IPty.onData` のイベントリスナー内で `Terminal.write` を呼び出す
- [x] バックエンドの出力をヘッドレス端末に流し込む処理を実装する
### memo
- バック圧制御: 現状は無視。xterm.jsの内部キューに依存する。
- パイプライン: `backend.onData` -> `terminal.write` の単純接続。

## 1-5. ライフサイクル管理
- [x] `dispose()` メソッドを実装する
- [x] プロセス、xtermインスタンス、イベントリスナーを適切に破棄・解除する処理を書く
### memo
- プロセス終了時: `ConchSession` は自動で破棄しない（ログ閲覧のため）。`dispose()` は明示的に呼び出す設計。

# タスク2: プログラム向け操作API (`I/O Interface`) の実装

## 2-1. `write` メソッドの実装
- [x] `ConchSession` に `write(data: string)` を追加する
- [x] バックエンド (IPty) へデータを送信する基本メソッドを作る

## 2-2. OS判定と改行コード定数の導入
- [x] 実行環境 (Windows/Posix) に応じた改行コード (`\r` or `\n`) を保持する定数または設定を持たせる
### memo
- 以前の議論では `newline` プロパティの導入を検討したが、**入力（コマンド実行）においては `\r` (CR) が全OS共通で安全** であるため、一旦プロパティ化は見送り、`\r` 固定で実装する方針に変更（YAGNI）。

## 2-3. `execute` (コマンド実行) メソッドの実装
- [x] 文字列を受け取り、末尾に適切な改行コードを付与して `write` を呼ぶコンビニエンスメソッドを作る
### memo
- **完了検知について**:
    - 本PoCでは「コマンド完了待ち」は実装しない（エージェントがスナップショットを見て判断するWait & See方式）。
    - 将来的な拡張として、VSCodeのような「Shell Integration (OSC 133;A 等の不可視シーケンスによるプロンプト検知)」の導入を検討する。

## 2-4. `resize` メソッドの実装
- [x] `ConchSession` に `resize(cols, rows)` を追加する
- [x] xterm と IPty 両方のサイズを同期して変更する処理を書く

## 2-5. エラーハンドリング
- [x] プロセスが既に終了している場合に書き込もうとした際の例外処理を追加する
- [x] 必要であれば書き込みバッファ溢れの考慮を追加する
### memo
- `LocalPty.write` および `resize` 内で `try-catch` し、例外発生時（プロセス終了後など）は `console.warn` でログ出力のみ行い、上位には伝播させない方針を採用。

# タスク3: 「人間の景色」生成API (`Snapshot Engine`) の開発

## 3-1. バッファ取得ロジックの実装
- [ ] xterm の `buffer.active` から行データをループで取り出す基本ロジックを `getSnapshot()` に実装する

## 3-2. 行レンダリングの調整
- [ ] `line.translateToString()` のオプション引数 (`trimRight` 等) を検討する
- [ ] 見た目を維持しつつ扱いやすい文字列形式を決定する

## 3-3. カーソル位置の取得
- [ ] `buffer.active.cursorX`, `buffer.active.cursorY` を取得する
- [ ] スナップショット取得時点でのカーソル座標を特定する

## 3-4. ビューポート制御 (スクロール対応)
- [ ] 全バッファを返すのではなく、現在のビューポート（表示領域）や、指定した範囲の行だけを取得するオプション引数を追加する

## 3-5. 戻り値の構造化
- [ ] 単純な文字列だけでなく、`{ text: string, cursor: { x, y }, ... }` というリッチなオブジェクトを返すように型定義と実装を修正する

# タスク4: Telnetサーバーの「介入・監視」機能の統合
### memo
- このレイヤーは「Interaction Adapters」として位置づけられる。
- Telnetだけでなく、MCP Server, WebSocket(Browser), VSCode IPCなども同列のアダプターとして実装可能。
- `ConchSession` はこれらのアダプターに対して中立であるべき。

## 4-1. イベントエミッターの整備
- [ ] `ConchSession` に `onOutput(callback)` を追加する
- [ ] ターミナル出力（PTYからの生データ）を外部にブロードキャストできるようにする

## 4-2. Telnetサーバークラスの分離
- [ ] `src/index.ts` のサーバー部分を `TelnetServer` クラスとして切り出す
- [ ] 複数のクライアント接続を管理できるようにする

## 4-3. 接続ハンドラーの実装
- [ ] クライアント接続時に `ConchSession` の `onOutput` を購読し、セッションの出力をソケットに流す処理を書く

## 4-4. 入力の割り込み処理
- [ ] ソケットからの入力（人間が打ったキー）を `ConchSession.write()` に流し込み、エージェント操作と混在させる処理を書く

## 4-5. Telnet特有の処理 (NVT)
- [ ] Windows/Telnetクライアント特有の改行コード変換を実装する
- [ ] 基本的なTelnetネゴシエーション（ローカルエコーOFFなど）をサーバークラス内にカプセル化する

# タスク5: 結合テスト（PoCデモ）の作成

## 5-1. デモスクリプトの作成 (`examples/demo.ts`)
- [ ] `ConchSession` と `TelnetServer` をインスタンス化し、連携させて起動するエントリーポイントを作る

## 5-2. 自動操作シナリオの実装
- [ ] `setTimeout` 等を使い、「起動 -> 3秒後に `ls` -> 3秒後に `top`」のように自動でコマンドを打つロジックを組む

## 5-3. スナップショット監視の実装
- [ ] 定期的に `getSnapshot()` を呼び出し、コンソールに出力して「エージェントが見ている景色」が正しいか確認するループを作る

## 5-4. Telnet接続確認
- [ ] デモ稼働中に手元のターミナルから接続し、自動操作の様子が見えるか確認する
- [ ] キー入力で操作に干渉できるかを確認する

## 5-5. ドキュメント整備とクリーンアップ
- [ ] `README.md` に使い方を追記する
- [ ] 不要になった `src/index.ts` の古いコードを削除またはアーカイブする
